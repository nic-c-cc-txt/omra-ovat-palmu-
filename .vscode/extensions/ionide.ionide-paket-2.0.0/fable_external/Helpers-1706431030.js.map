{"version":3,"sources":["../../paket-files/Ionide/ionide-vscode-helpers/Helpers.fs"],"names":[],"mappings":"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","file":"Helpers-1706431030.js","sourceRoot":"D:/Programowanie/Projekty/Ionide/ionide-vscode-paket/release","sourcesContent":["namespace Ionide.VSCode.Helpers\n\nopen System\nopen Fable.Core\n\nmodule JS =\n\n    [<Emit(\"($0 != undefined)\")>]\n    let isDefined (o: obj) : bool = failwith \"never\"\n\n//---------------------------------------------------\n//PromisesExt (by Dave)\n//---------------------------------------------------\nmodule Promise =\n    open System\n    open Fable.Core\n    open Fable.Import\n    open Fable.Import.JS\n\n    /// <summary>\n    /// Creates new promise.\n    /// Constuctor function \"body\" is called with two arguments:\n    /// \"resolve\" - moves promise to fulfilled state, using provided argument as result\n    /// \"reject\" - moves promise to rejected state\n    /// </summary>\n    let create (body: ('T->unit) -> (obj->unit) -> unit) =\n        Promise.Create(fun (resolverFunc : Func<U2<_, _>, _>) (rejectorFunc : Func<_,_>) ->\n            body (fun v -> resolverFunc.Invoke(U2.Case1 v)) (fun e -> rejectorFunc.Invoke e))\n\n    /// <summary>\n    /// Standard map implementation.\n    /// </summary>\n    let map (a : 'T -> 'R) (pr : Promise<'T>) : Promise<'R> =\n        pr.``then``(\n            unbox<Func<'T, U2<'R, PromiseLike<'R>>>> a,\n            unbox<Func<obj,unit>> None\n        )\n\n    /// <summary>\n    /// Standard bind implementation.\n    /// </summary>\n    let bind (a : 'T -> Promise<'R>) (pr : Promise<'T>) : Promise<'R> =\n        pr.``then``(\n            unbox<Func<'T, U2<'R, PromiseLike<'R>>>> a,\n            unbox<Func<obj,unit>> None\n        )\n\n    /// <summary>\n    /// Bind for rejected promise.\n    /// </summary>\n    let catch (a : obj -> Promise<'R>) (pr : Promise<'T>) : Promise<'R> =\n        pr.``then``(\n            unbox<Func<'T, U2<'R, PromiseLike<'R>>>> None,\n            unbox<Func<obj,U2<'R, PromiseLike<'R>>>> a\n        )\n\n    /// <summary>\n    /// Combination of bind and catch methods. If promise in fulfilled state - a is bound, if in rejected state - then b.\n    /// </summary>\n    let either (a : 'T -> Promise<'R>) (b: obj -> Promise<'R>) (pr : Promise<'T>) : Promise<'R> =\n        pr.``then``(\n            unbox<Func<'T, U2<'R, PromiseLike<'R>>>> a,\n            unbox<Func<obj,U2<'R, PromiseLike<'R>>>> b\n        )\n\n    /// <summary>\n    /// Creates promise (in pending state) from the supplied value.\n    /// </summary>\n    let lift<'T> (a : 'T) : Promise<'T> =\n        Promise.resolve(U2.Case1 a)\n\n    /// <summary>\n    /// Creates promise (in rejected state) with supplied reason.\n    /// </summary>\n    let reject<'T> reason : Promise<'T> =\n        Promise.reject<'T> reason\n\n    /// <summary>\n    /// Allows handing promise which is in fulfilled state.\n    /// Can be used for side-effects.\n    /// </summary>\n    let onSuccess (a : 'T -> unit) (pr : Promise<'T>) : Promise<'T> =\n        pr.``then``(\n            unbox<Func<'T, U2<'T, PromiseLike<'T>>>> (fun value -> a value; value),\n            unbox<Func<obj,unit>> None\n        )\n\n    /// <summary>\n    /// Allows handing promise which is in rejected state. Propagates rejected promise, to allow chaining.\n    /// Can be used for side-effects.\n    /// </summary>\n    let onFail (a : obj -> unit) (pr : Promise<'T>) : Promise<'T> =\n        pr.catch (unbox<Func<obj, U2<'T, PromiseLike<'T>>>> (fun reason -> a reason |> ignore; reject reason))\n\n    let all (prs : Promise<'T> seq) =\n        Promise.all (unbox prs)\n\n    let empty<'T> = lift (unbox<'T>null)\n\n    type PromiseBuilder() =\n        member inline x.Bind(m,f) = bind f m\n        member inline x.Return(a) = lift a\n        member inline x.ReturnFrom(a) = a\n        member inline x.Zero() = Fable.Import.JS.Promise.resolve()\n\n[<AutoOpen>]\nmodule PromiseBuilderImp =\n    let promise = Promise.PromiseBuilder()\n\n\n\n//---------------------------------------------------\n//VS Code Helpers\n//---------------------------------------------------\nmodule VSCode =\n    open Fable.Import.vscode\n\n    let getPluginPath pluginName =\n        let ext = extensions.getExtension pluginName\n        ext.extensionPath\n\n\n//---------------------------------------------------\n//Process Helpers\n//---------------------------------------------------\nmodule Process =\n    let splitArgs cmd =\n        if cmd = \"\" then\n            [||]\n        else\n            cmd.Split(' ')\n            |> Array.toList\n            |> List.fold (fun (quoted : string option,acc) e ->\n                if quoted.IsSome then\n                    if e.EndsWith \"\\\"\" then None, (quoted.Value + \" \" + e).Replace(\"\\\"\", \"\")::acc\n                    else Some (quoted.Value + \" \" + e), acc\n                else\n                    if e.StartsWith \"\\\"\" &&  e.EndsWith \"\\\"\" then None, e.Replace(\"\\\"\", \"\")::acc\n                    elif e.StartsWith \"\\\"\" then Some e, acc\n                    else None, e::acc\n            ) (None,[])\n            |> snd\n            |> List.rev\n            |> List.toArray\n\n    open Fable.Import.JS\n    open Fable.Import.Node\n    open Fable.Import.vscode\n    open Fable.Core.JsInterop\n\n\n    let isWin () = ``process``.platform = \"win32\"\n    let isMono () = ``process``.platform <> \"win32\"\n\n    let onExit (f : obj -> _) (proc : child_process_types.ChildProcess) =\n        proc.on(\"exit\", f |> unbox) |> ignore\n        proc\n\n    let onOutput (f : obj -> _) (proc : child_process_types.ChildProcess) =\n        proc.stdout?on $ (\"data\", f |> unbox) |> ignore\n        proc\n\n    let onErrorOutput (f : obj -> _) (proc : child_process_types.ChildProcess) =\n        proc.stderr?on $ (\"data\", f |> unbox) |> ignore\n        proc\n\n    let onError (f: obj -> _) (proc : child_process_types.ChildProcess) =\n        proc?on $ (\"error\", f |> unbox) |> ignore\n        proc\n\n\n    let spawn location linuxCmd (cmd : string) =\n        let cmd' = splitArgs cmd |> ResizeArray\n\n        let options =\n            createObj [\n                \"cwd\" ==> workspace.rootPath\n            ]\n        if isWin () || linuxCmd = \"\" then\n\n            child_process.spawn(location, cmd', options)\n        else\n            let prms = seq { yield location; yield! cmd'} |> ResizeArray\n            child_process.spawn(linuxCmd, prms, options)\n\n    let spawnInDir location linuxCmd (cmd : string) =\n        let cmd' = splitArgs cmd |> ResizeArray\n\n        let options =\n            createObj [\n                \"cwd\" ==> (path.dirname location)\n            ]\n        if isWin () || linuxCmd = \"\" then\n\n            child_process.spawn(location, cmd', options)\n        else\n            let prms = seq { yield location; yield! cmd'} |> ResizeArray\n            child_process.spawn(linuxCmd, prms, options)\n\n\n    let spawnWithNotification location linuxCmd (cmd : string) (outputChannel : OutputChannel) =\n        spawn location linuxCmd cmd\n        |> onOutput(fun e -> e.ToString () |> outputChannel.append)\n        |> onError (fun e -> e.ToString () |> outputChannel.append)\n        |> onErrorOutput(fun e -> e.ToString () |> outputChannel.append)\n\n    let spawnWithNotificationInDir location linuxCmd (cmd : string) (outputChannel : OutputChannel) =\n        spawnInDir location linuxCmd cmd\n        |> onOutput(fun e -> e.ToString () |> outputChannel.append)\n        |> onError (fun e -> e.ToString () |> outputChannel.append)\n        |> onErrorOutput(fun e -> e.ToString () |> outputChannel.append)\n\n    let toPromise (proc : child_process_types.ChildProcess) =\n        Promise.Create<string>(fun (resolve : Func<U2<string,PromiseLike<string>>,unit>) (error : Func<obj,_>) ->\n            proc\n            |> onExit(fun (code) -> code.ToString() |> Case1 |> unbox resolve )\n            |> ignore\n        )\n\n\n    let exec location linuxCmd cmd : Promise<Error * Buffer *Buffer> =\n        let options =\n            createObj [\n                \"cwd\" ==> workspace.rootPath\n            ]\n        Promise.Create<Error * Buffer *Buffer>(fun (resolve : Func<U2<Error * Buffer *Buffer,PromiseLike<Error * Buffer *Buffer>>,_>) (error : Func<obj,_>) ->\n            let execCmd =\n                if isWin () then location + \" \" + cmd\n                else linuxCmd + \" \" + location + \" \" + cmd\n            child_process.exec(execCmd, options,\n                Func<Error,Buffer,Buffer,unit>(fun (e : Error) (i : Buffer) (o : Buffer) ->\n                    let arg = e,i,o\n                    resolve.Invoke(U2.Case1 arg))) |> ignore)\n\n\n//---------------------------------------------------\n//Settings Helpers\n//---------------------------------------------------\nmodule Settings =\n    open Fable.Import.vscode\n    open Fable.Import.Node\n\n    module Toml =\n        [<Emit(\"toml.parse($0)\")>]\n        let parse (str : string) : 'a = failwith \"JS\"\n\n    type FakeSettings = {\n        linuxPrefix : string\n        command : string\n        build : string\n        parameters : string []\n        test : string\n    }\n\n    type WebPreviewSettings = {\n        linuxPrefix : string\n        command : string\n        host : string\n        port : int\n        script : string\n        build : string\n        startString : string\n        parameters : string []\n        startingPage : string\n    }\n\n    type Settings = {\n        Fake : FakeSettings\n        WebPreview : WebPreviewSettings\n    }\n\n    let loadOrDefault<'a> (map : Settings -> 'a)  (def :'a) =\n        try\n            let path = workspace.rootPath + \"/.ionide\"\n            let t = fs.readFileSync(path).toString ()\n                    |> Toml.parse\n                    |> map\n            if JS.isDefined t then t else def\n        with\n        | _ -> def\n"]}